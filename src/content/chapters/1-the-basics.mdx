---
chapter: 1
title: "Asoslar"
shortname: Asoslar
slug: the-basics
updatedAt: 2023-07-19T18:57:54.630Z
---

Ushbu maqolani yozish davomida meni takror-takror hayratga solgan narsa shuki — kompyuterlar aslida juda oddiy tuzilmaga ega ekan. Hanuzgacha o‘zimni qiynab, ularni haddan tashqari murakkab yoki chuqurroq abstraksiyalarga asoslangan deb o‘ylashga urinishimdan o‘zimni to‘xtatishim qiyin. Agar davom etishdan oldin miyangizda muhrlab qo‘yishingiz kerak bo‘lgan bitta fikr bo‘lsa, u ham shu bo‘lsin: sizga oddiy tuyulgan narsa, aslida ham oddiydir. Bu soddalik — ba’zida juda go‘zal, ba’zida esa juda, juda axmoqona bo‘lishi mumkin.

Keling, kompyuteringiz qanday ishlashini asosiy jihatlaridan boshlaylik.

## Kompyuterlar qanday tuzilgan

*Markaziy protsessor* (CPU) kompyuterning barcha hisob kitoblari uchun javobgardir. Eng muhim jihati shuki: kompyuteringizni yoqqaningiz zahoti u ishga tushadi va to‘xtovsiz buyruq ustidan buyruqlarni bajarishni boshlaydi.

Birinchi ishlab chiqilgan CPU [Intel 4004](http://www.intel4004.com/) edi, 60-yillarning oxirida italiyalik fizik va muhandis Federiko Faggin tomonidan ishlab chiqilgan. Bu — hozirgi zamonaviy [64-bit](https://en.wikipedia.org/wiki/64-bit_computing) tizimlardan farqli o‘laroq, 4-bitli arxitektura edi, va u zamonaviy protsessorlarga nisbatan ancha sodda bo‘lgan, biroq uning soddaligi bugungi protsessorlarda ham ma'lum darajada saqlanib qolgan.

CPU tomonidan bajariladigan “buyruqlar” — bu shunchaki ikkilik (binary) ma’lumotdan iborat: odatda bir yoki ikki bayt buyruqning o‘zini ifodalaydi (ya’ni opcode), undan keyin esa buyruqni bajarish uchun kerakli qo‘shimcha ma’lumotlar keladi.Biz “mashina kodi” deb ataydigan narsa — aslida ketma-ket joylashgan ana shu ikkilik buyruqlar to‘plamidan boshqa narsa emas. [Assembly](https://en.wikipedia.org/wiki/Assembly_language) — mashina kodini yozish va o‘qishni osonlashtiradigan inson uchun qulay sintaksis bo‘lib, u doimo CPU tushuna oladigan ikkilik kodga kompilyatsiya qilinadi.

<img src='/images/assembly-to-machine-code-translation.png' loading='eager' style='max-width: 400px;' alt='A diagram demonstrating how machine code translates to assembly and back. A bidirectional arrow connects three examples: Machine Code (Binary) followed by 3 bytes of binary numbers, Machine Code (Hex) followed by those 3 bytes translated to hex (0x83, 0xC3, 0x0A), and Assembly followed by "add ebx, 10". The Assembly and Machine Code are color-coded so it is clear that each byte of the machine code translate to one word in the assembly.' width='935' height='505' />

> Qo‘shimcha eslatma: buyruqlar har doim mashina kodida yuqoridagi misoldagidek 1:1 nisbatda ifodalanmaydi. Masalan, `add eax, 512` buyrug‘i mashina kodida quyidagicha tarjima qilinadi: `05 00 02 00 00`.
> 
> Birinchi bayt (05) — bu EAX registriga 32-bitli son qo‘shish buyrug‘ini ifodalovchi maxsus opcode (buyruq kodi). Qolgan baytlar esa 512 (0x200) sonining [little-endian](https://en.wikipedia.org/wiki/Endianness) bayt tartibida yozilgan ko‘rinishidir.
>
> Defuse Security assembly va mashina kodi bir biriga qanday aylanishi ko'rish va tajriba qilish uchun [foydali vosita](https://defuse.ca/online-x86-assembler.htm) yaratgan.

RAM kompyuteringizning asosiy xotira qurilmasidir unda kompyuteringizda ishlayotgan dasturlar foydalanadigan barcha ma’lumotlar saqlanadi. Bu ma’lumotlarga dastur kodi ham, operatsion tizimning yadrosi (core) ishlayotgan kodlari ham kiradi. CPU (markaziy protsessor) mashina kodini doimiy ravishda RAMdan o‘qiydi, va har qanday kod RAM ga yuklanmaguncha uni ishlatib bo‘lmaydi.

CPUda instruction pointer (IP) mavjud bo‘lib, u keyingi bajarilishi kerak bo‘lgan buyruq manzilini saqlaydi. Har bir buyruq bajarilgach, CPU IP ni yangilaydi va jarayon takrorlanadi. Bu jarayon fetch-execute cycle (CPU keyingi bajarilishi kerak bo‘lgan buyruqni RAMdan oladi. Bu buyruq manzili instruction pointer (IP) yordamida aniqlanadi va bajariladi) deb ataladi.

<img src='/images/fetch-execute-cycle.png' loading='lazy' style='max-width: 360px; margin: 0 auto;' alt='A diagram demonstrating the fetch-execute cycle. There are two bubbles of text. The first is labeled "Fetch" and has the text "Read instruction from memory at the current instruction pointer." The second is titled "Execute" and has the text "Run the instruction and then move the instruction pointer." The fetch bubble has an arrow pointing to the execute bubble, and the execute bubble has an arrow pointing back to the fetch bubble, implying a repeated process.' width='848' height='458' />

Buyruq bajarilgandan so‘ng, IP (instruction pointer) RAMdagi keyingi buyruq joylashgan manzilga siljiydi. Buyruqlar qanday tartibda yozilgan bo‘lsa IP xotiradan shuni ketma-ket o‘qib, bajara boshlaydi. Ba’zi buyruqlar esa IP’ga boshqa joyga o’tishni buyuradi — ya’ni, “sakrash”ni. Ba'zilari esa bu sakrashni faqat ma’lum bir shart bajarilganda amalga oshiradi. Bu esa shartli kodlar(masalan `if`) va qayta ishlatiladigan kodlar(masalan `function`) yozish imkonini beradi.

Bu IP(intructione pointer) [*register*](https://en.wikipedia.org/wiki/Processor_register) da saqlanadi. Registrlar — bu CPU o‘qishi va yozishi uchun juda tez ishlovchi kichik xotira bo‘laklaridir. Har bir CPU arxitekturasida qat’iy belgilangan registrlar to‘plami mavjud, Ular hisoblash jarayonida vaqtincha qiymatlarni saqlashdan tortib, protsessorni sozlashgacha bo‘lgan barcha vazifalarda ishlatiladi.

Ba’zi registrlarga mashina kodi orqali bevosita murojaat qilish mumkin, masalan, oldingi rasmdagi `ebx` registri kabi.

Ba’zi registrlar faqat CPU ichida ishlatiladi, biroq ko‘pincha maxsus ko‘rsatmalar yordamida ularni o‘qish yoki yangilash mumkin. Masalan, instruction pointer (IP) bevosita o‘qib bo‘lmaydi, ammo uni masalan, sakrash (jump) ko‘rsatmasi orqali yangilash mumkin.

## Protsessorlar sodda

Keling, asl savolga qaytaylik: kompyuteringizda dasturni ishga tushirganingizda nima sodir bo‘ladi? Avvalo, uni ishga tushirishga tayyorlash uchun bir qancha murakkab jarayonlar amalga oshadi — bularni keyinroq batafsil ko‘rib chiqamiz — ammo jarayon oxirida mashina kodi fayl ko‘rinishida mavjud bo‘ladi. Operatsion tizim bu kodni RAMga yuklaydi va CPUga ko‘rsatkichni (instruction pointer) shu RAMdagi manzilga o‘tkazishni buyuradi. CPU esa odatdagidek fetch-execute siklini davom ettiradi va shu tariqa dastur bajarila boshlaydi!

(Bu men uchun o‘zimni chalg‘itayotgan paytlardan biri edi — jiddiy aytaman, aynan shu tarzda siz hozir ushbu maqolani o‘qiyotgan dastur ishlamoqda! Sizning CPU’ingiz brauzeringizning buyruqlarini RAM’dan ketma-ket olib, to‘g‘ridan-to‘g‘ri bajarib bormoqda va ular ayni paytda ushbu maqolani ekranga chiqarishyapti.)

<img src='/images/instruction-pointer.png' loading='lazy' style='max-width: 400px;' alt='A diagram depicting a series of bytes of machine code in RAM. A highlighted byte is pointed to by an arrow labeled "Instruction Pointer," and there are arrows representing how the instruction pointer moves forward in RAM.' width='935' height='372' />

Ma’lum bo‘lishicha, CPUlar juda sodda dunyoqarashga ega; ular faqat hozirgi IP(instruction pointer) va ichki holatning bir qismini ko‘radi. Jarayonlar butunlay operatsion tizimning abstraktsiyalari bo‘lib, CPUlar ularni tabiiy ravishda tushunmaydi yoki nazorat qilmaydi.

*Jarayonlar — bu operatsion tizim dasturchilari tomonidan yaratilgan abstraktsiyalar, katta kompaniyalar esa shular yordamida ko‘proq kompyuter sotishni maqsad qilgan, \*ular shunchaki bu narsani hayratlanarli qilib ko‘rsatishadi.\**

Men uchun bu javobdan ko‘ra ko‘proq savollar tug‘diradi:

1. Agar CPU ketma-ket buyruqlarni bajarib, ko‘pjarayonlilikni(multiprocessing) tushunmasa, u ishga tushirgan dastur ichida qanday qilib to‘xtab yoki bloklanib qolmaydi? Bir nechta dasturlar bir vaqtning o‘zida qanday ishlay oladi?
2. Agar dasturlar to‘g‘ridan-to‘g‘ri CPUda ishlasa va CPU RAMga to‘g‘ridan-to‘g‘ri kira olsa, unda nima uchun kod boshqa jarayonlarning xotirasiga yoki, undan ham yomoni, yadro (kernel) xotirasiga kira olmaydi?
3. Gap kelganda, nima mexanizm har bir jarayonning istalgan buyruqni bajarib, kompyuteringizda istalgan ishni qilishidan to‘xtatadi? va haqiqatdan, SYSCALL nima?

Xotira haqida savol alohida bo‘limga ajratilgan va [5-bobda](/the-translator-in-your-computer) ko‘rib chiqilgan — qisqacha aytganda, CPU xotira bilan ishlashda, ba'zan to'g'ridan-to'g'ri manzillarga murojaat qilmaydi. Buning o'rniga, xotira manzillari boshqa joylarga "qayta joylashtiriladi", ya'ni boshqacha tarzda o'qiladi yoki yoziladi. Bu esa manzillarni boshqarishning o'ziga xos usuli bo'lib, ko'pincha tezlikni va xavfsizlikni oshirishga yordam beradi. Hozircha, biz dasturlar barcha RAMga to'g'ridan-to'g'ri kirishi mumkin va kompyuterlar bir vaqtning o'zida faqat bitta jarayonni bajarishi mumkin deb o'ylaymiz. Biz bu ikki taxminni o'z vaqtida tushuntirib beramiz.Endi biz syscall'lar va xavfsizlik halqalari dunyosiga birinchi qadamni qo'yamiz.

Endi biz syscall'lar va [xavfsizlik uchun imtiyoz darajalari](https://en.wikipedia.org/wiki/Protection_ring) dunyosiga birinchi qadamni qo'yamiz.

> **Aside: Aytgancha Kernel o'zi nima?**
> 
> Kompyuteringizdagi operatsion tizim — masalan, macOS, Windows yoki Linux — bu kompyuterni ishlatishga imkon beruvchi dasturiy ta'minotdir. U asosiy tizim vazifalarini bajaradi. “Asosiy vazifalar” degani turlicha talqin qilinishi mumkin: ba'zilar uchun bu tizim bilan birga keladigan dasturlar, shriftlar yoki ikonkalardir.
> 
> Kernel esa operatsion tizimning eng asosiy, markaziy qismidir. Kompyuteringiz yoqilganda, dastlab bajariladigan buyruqlar aynan shu kernelga tegishlidir. Kernel kompyuteringizning xotirasi, qurilmalari (masalan, klaviatura, monitor, disklar) va boshqa resurslariga to‘liq yoki deyarli to‘liq kirish huquqiga ega. Shuningdek, u siz o‘rnatgan barcha dasturlarni — ya’ni foydalanuvchi darajasidagi (userland) dasturlarni — ishga tushirish va boshqarish uchun javobgardir. Ushbu maqolada biz kernelning qanday qilib bu darajadagi kirish huquqiga ega ekanini, va nima uchun foydalanuvchi darajasidagi dasturlar bu huquqlarga ega emasligini o‘rganamiz.
>
> Linux — bu faqat kernel bo‘lib, uni amalda foydalanish uchun unga ko‘plab foydalanuvchi darajasidagi(userland) dasturlar, masalan, shell lar va display server lar kerak bo‘ladi. macOS’dagi kernel "XNU" deb ataladigan Unix-ga o‘xshash tizim hisoblanadi.
Zamonaviy Windows tizimi esa "NT Kernel" deb nomlangan kernel asosida ishlaydi.

## Two Rings to Rule Them All

The *mode* (sometimes called privilege level or ring) a processor is in controls what it's allowed to do. Modern architectures have at least two options: kernel/supervisor mode and user mode. While an architecture might support more than two modes, only kernel mode and user mode are commonly used these days.

In kernel mode, anything goes: the CPU is allowed to execute any supported instruction and access any memory. In user mode, only a subset of instructions is allowed, I/O and memory access is limited, and many CPU settings are locked. Generally, the kernel and drivers run in kernel mode while applications run in user mode.

Processors start in kernel mode. Before executing a program, the kernel initiates the switch to user mode.

<img src='/images/kernel-mode-vs-user-mode.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='Two fake iMessage screenshots demonstrating the different between user and kernel mode protections. The first, labeled Kernel Mode: right side says "Read this protected memory!", left side replies "Here you go, dear :)". The second, labeled User Mode: right side says "Read this protected memory!", left side replies "No! Segmentation fault!"' width='1072' height='433' />

An example of how processor modes manifest in a real architecture: on x86-64, the current privilege level (CPL) can be read from a register called `cs` (code segment). Specifically, the CPL is contained in the two [least significant bits](https://en.wikipedia.org/wiki/Bit_numbering) of the `cs` register. Those two bits can store x86-64's four possible rings: ring 0 is kernel mode and ring 3 is user mode. Rings 1 and 2 are designed for running drivers but are only used by a handful of older niche operating systems. If the CPL bits are `11`, for example, the CPU is running in ring 3: user mode.
 
## What Even is a Syscall?

Programs run in user mode because they can't be trusted with full access to the computer. User mode does its job, preventing access to most of the computer — but programs need to be able to access I/O, allocate memory, and interact with the operating system *somehow*! To do so, software running in user mode has to ask the operating system kernel for help. The OS can then implement its own security protections to prevent programs from doing anything malicious.

If you've ever written code that interacts with the OS, you'll probably recognize functions like `open`, `read`, `fork`, and `exit`. Below a couple of layers of abstraction, these functions all use *system calls* to ask the OS for help. A system call is a special procedure that lets a program start a transition from user space to kernel space, jumping from the program's code into OS code.

User space to kernel space control transfers are accomplished using a processor feature called [*software interrupts*](https://en.wikipedia.org/wiki/Interrupt#Software_interrupts):

1. During the boot process, the operating system stores a table called an [*interrupt vector table*](https://en.wikipedia.org/wiki/Interrupt_vector_table) (IVT; x86-64 calls this the [interrupt descriptor table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table)) in RAM and registers it with the CPU. The IVT maps interrupt numbers to handler code pointers.

  <img src='/images/interrupt-vector-table.png' loading='lazy' style='max-width: 300px; margin: 0 auto;' alt='A image of a table captioned "Interrupt Vector Table". The first column, labeled with a number sign, has a series of numbers starting at 01 and going to 04. The corresponding second column of the table, labeled "Handler Address", contains a random 8-byte-long hex number per entry. The bottom of the table has the text "So on and such forth..."' width='555' height='463' />

2. Then, userland programs can use an instruction like [INT](https://www.felixcloutier.com/x86/intn:into:int3:int1) which tells the processor to look up the given interrupt number in the IVT, switch to kernel mode, and then jump the instruction pointer to the memory address stored in the IVT.

When this kernel code finishes, it uses an instruction like [IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) to tell the CPU to switch back to user mode and return the instruction pointer to where it was when the interrupt was triggered.

(If you were curious, the interrupt ID used for system calls on Linux is `0x80`. You can read a list of Linux system calls on [Michael Kerrisk's online manpage directory](https://man7.org/linux/man-pages/man2/syscalls.2.html).)

### Wrapper APIs: Abstracting Away Interrupts

Here's what we know so far about system calls:

- User mode programs can't access I/O or memory directly. They have to ask the OS for help interacting with the outside world.
- Programs can delegate control to the OS with special machine code instructions like INT and IRET.
- Programs can't directly switch privilege levels; software interrupts are safe because the processor has been preconfigured *by the OS* with where in the OS code to jump to. The interrupt vector table can only be configured from kernel mode.

Programs need to pass data to the operating system when triggering a syscall; the OS needs to know which specific system call to execute alongside any data the syscall itself needs, for example, what filename to open. The mechanism for passing this data varies by operating system and architecture, but it's usually done by placing data in certain registers or on the stack before triggering the interrupt.

The variance in how system calls are called across devices means it would be wildly impractical for programmers to implement system calls themselves for every program. This would also mean operating systems couldn't change their interrupt handling for fear of breaking every program that was written to use the old system. Finally, we typically don't write programs in raw assembly anymore — programmers can't be expected to drop down to assembly any time they want to read a file or allocate memory.

<img src='/images/syscall-architecture-differences.png' loading='lazy' style='max-width: 650px; margin: 0 auto;' alt='A drawing captioned "System calls are implemented differently across architectures." On the left is a smiling CPU receiving some binary and spitting out a filename, file.txt. Separated on the right is a different CPU receiving the same binary data but with a confused and nauseous facial expression.' width='1057' height='360' />

So, operating systems provide an abstraction layer on top of these interrupts. Reusable higher-level library functions that wrap the necessary assembly instructions are provided by [libc](https://www.gnu.org/software/libc/) on Unix-like systems and part of a library called [ntdll.dll](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/libraries-and-headers) on Windows. Calls to these library functions themselves don't cause switches to kernel mode, they're just standard function calls. Inside the libraries, assembly code does actually transfer control to the kernel, and is a lot more platform-dependent than the wrapping library subroutine.

When you call `exit(1)` from C running on a Unix-like system, that function is internally running machine code to trigger an interrupt, after placing the system call's opcode and arguments in the right registers/stack/whatever. Computers are so cool!

## The Need for Speed / Let's Get CISC-y

Many [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) architectures like x86-64 contain instructions designed for system calls, created due to the prevalence of the system call paradigm.

Intel and AMD managed not to coordinate very well on x86-64; it actually has *two* sets of optimized system call instructions. [SYSCALL](https://www.felixcloutier.com/x86/syscall.html) and [SYSENTER](https://www.felixcloutier.com/x86/sysenter) are optimized alternatives to instructions like `INT 0x80`. Their corresponding return instructions, [SYSRET](https://www.felixcloutier.com/x86/sysret.html) and [SYSEXIT](https://www.felixcloutier.com/x86/sysexit), are designed to transition quickly back to user space and resume program code.

(AMD and Intel processors have slightly different compatibility with these instructions. `SYSCALL` is generally the best option for 64-bit programs, while `SYSENTER` has better support with 32-bit programs.)

Representative of the style, [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) architectures tend not to have such special instructions. AArch64, the RISC architecture Apple Silicon is based on, uses only [one interrupt instruction](https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/SVC--Supervisor-Call-) for syscalls and software interrupts alike. I think Mac users are doing fine&nbsp;:)

---

Whew, that was a lot! Let's do a brief recap:

- Processors execute instructions in an infinite fetch-execute loop and don't have any concept of operating systems or programs. The processor's mode, usually stored in a register, determines what instructions may be executed. Operating system code runs in kernel mode and switches to user mode to run programs.
- To run a binary, the operating system switches to user mode and points the processor to the code's entry point in RAM. Because they only have the privileges of user mode, programs that want to interact with the world need to jump to OS code for help. System calls are a standardized way for programs to switch from user mode to kernel mode and into OS code.
- Programs typically use these syscalls by calling shared library functions. These wrap machine code for either software interrupts or architecture-specific syscall instructions that transfer control to the OS kernel and switch rings. The kernel does its business and switches back to user mode and returns to the program code.

Let’s figure out how to answer my first question from earlier:

> If the CPU doesn't keep track of more than one process and just executes instruction after instruction, why doesn't it get stuck inside whatever program it's running? How can multiple programs run at once?

The answer to this, my dear friend, is also the answer to why Coldplay is so popular... clocks! (Well, technically timers. I just wanted to shoehorn that joke in.)
